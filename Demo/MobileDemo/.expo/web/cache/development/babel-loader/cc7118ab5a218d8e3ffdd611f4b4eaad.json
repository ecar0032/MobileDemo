{"ast":null,"code":"import { FRACTION_VALUES } from \"../../shared/constants\";\nimport { valueForSize } from \"../../shared/methods\";\nexport var isHidden = function isHidden(sizeNames, activeSize, props) {\n  var value = props.hidden === true || props.visible === false;\n\n  for (var i = 0; i < sizeNames.length; i += 1) {\n    var size = sizeNames[i];\n    var keyVisible = size + \"Visible\";\n    var keyHidden = size + \"Hidden\";\n\n    if (Object.prototype.hasOwnProperty.call(props, keyVisible)) {\n      value = !props[keyVisible];\n    }\n\n    if (Object.prototype.hasOwnProperty.call(props, keyHidden)) {\n      value = props[keyHidden];\n    }\n\n    if (activeSize === size) {\n      return value;\n    }\n  }\n\n  return value;\n};\n\nvar getSize = function getSize(sizeNames, activeSize, props) {\n  var initialValue = props.size || '1';\n\n  var keySelector = function keySelector(size) {\n    return size + \"Size\";\n  };\n\n  return valueForSize(sizeNames, activeSize, props, initialValue, keySelector);\n};\n\nexport var determineSize = function determineSize(sizeNames, activeSize, props) {\n  var size = getSize(sizeNames, activeSize, props);\n\n  if (size === 'stretch') {\n    return size;\n  }\n\n  if (typeof size === 'string') {\n    if (size.endsWith('%')) {\n      return size;\n    }\n\n    return FRACTION_VALUES[size] + \"%\";\n  }\n\n  return size;\n};","map":{"version":3,"sources":["C:/Users/mikea/Documents/GitHub/MobileDemo/Demo/MobileDemo/node_modules/react-native-responsive-layout/src/components/block/methods.js"],"names":["FRACTION_VALUES","valueForSize","isHidden","sizeNames","activeSize","props","value","hidden","visible","i","length","size","keyVisible","keyHidden","Object","prototype","hasOwnProperty","call","getSize","initialValue","keySelector","determineSize","endsWith"],"mappings":"AAAA,SAASA,eAAT;AACA,SAASC,YAAT;AAkBA,OAAO,IAAMC,QAAQ,GAAG,SAAXA,QAAW,CAACC,SAAD,EAAYC,UAAZ,EAAwBC,KAAxB,EAAkC;AAExD,MAAIC,KAAK,GAAGD,KAAK,CAACE,MAAN,KAAiB,IAAjB,IAAyBF,KAAK,CAACG,OAAN,KAAkB,KAAvD;;AAEA,OAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGN,SAAS,CAACO,MAA9B,EAAsCD,CAAC,IAAI,CAA3C,EAA8C;AAC5C,QAAME,IAAI,GAAGR,SAAS,CAACM,CAAD,CAAtB;AACA,QAAMG,UAAU,GAAMD,IAAN,YAAhB;AACA,QAAME,SAAS,GAAMF,IAAN,WAAf;;AAKA,QAAIG,MAAM,CAACC,SAAP,CAAiBC,cAAjB,CAAgCC,IAAhC,CAAqCZ,KAArC,EAA4CO,UAA5C,CAAJ,EAA6D;AAC3DN,MAAAA,KAAK,GAAG,CAACD,KAAK,CAACO,UAAD,CAAd;AACD;;AAED,QAAIE,MAAM,CAACC,SAAP,CAAiBC,cAAjB,CAAgCC,IAAhC,CAAqCZ,KAArC,EAA4CQ,SAA5C,CAAJ,EAA4D;AAC1DP,MAAAA,KAAK,GAAGD,KAAK,CAACQ,SAAD,CAAb;AACD;;AAGD,QAAIT,UAAU,KAAKO,IAAnB,EAAyB;AACvB,aAAOL,KAAP;AACD;AACF;;AAED,SAAOA,KAAP;AACD,CA3BM;;AAsCP,IAAMY,OAAO,GAAG,SAAVA,OAAU,CAACf,SAAD,EAAYC,UAAZ,EAAwBC,KAAxB,EAAkC;AAChD,MAAMc,YAAY,GAAId,KAAK,CAACM,IAAN,IAAc,GAApC;;AACA,MAAMS,WAAW,GAAG,SAAdA,WAAc,CAAAT,IAAI;AAAA,WAAOA,IAAP;AAAA,GAAxB;;AAEA,SAAOV,YAAY,CAACE,SAAD,EAAYC,UAAZ,EAAwBC,KAAxB,EAA+Bc,YAA/B,EAA6CC,WAA7C,CAAnB;AACD,CALD;;AA0BA,OAAO,IAAMC,aAAa,GAAG,SAAhBA,aAAgB,CAAClB,SAAD,EAAYC,UAAZ,EAAwBC,KAAxB,EAAkC;AAC7D,MAAMM,IAAI,GAAGO,OAAO,CAACf,SAAD,EAAYC,UAAZ,EAAwBC,KAAxB,CAApB;;AAEA,MAAIM,IAAI,KAAK,SAAb,EAAwB;AACtB,WAAOA,IAAP;AACD;;AAED,MAAK,OAAOA,IAAR,KAAkB,QAAtB,EAAgC;AAE9B,QAAIA,IAAI,CAACW,QAAL,CAAc,GAAd,CAAJ,EAAwB;AACtB,aAAOX,IAAP;AACD;;AAGD,WAAUX,eAAe,CAACW,IAAD,CAAzB;AACD;;AAED,SAAOA,IAAP;AACD,CAlBM","sourcesContent":["import { FRACTION_VALUES } from '../../shared/constants';\r\nimport { valueForSize } from '../../shared/methods';\r\n\r\n\r\n/**\r\n * Determines whether object is hidden depending on currently active size.\r\n *\r\n * Since attributes cascade from smaller to larger dimensions it will determine\r\n * which one to use and return it's value. This enables easy way to hide\r\n * elements from determined size up.\r\n *\r\n * For example `mdHidden={true}` will hide element on medium sized but as well\r\n * on all larger sizes unless overridden.\r\n *\r\n * @param {Array<string>} sizeNames that grid supports ordered from smallest\r\n * @param {string} activeSize that is determined by grid\r\n * @param {Object} props object use as reference for values\r\n * @return {boolean}\r\n */\r\nexport const isHidden = (sizeNames, activeSize, props) => {\r\n  // Strictly check hidden and visible as default values\r\n  let value = props.hidden === true || props.visible === false;\r\n\r\n  for (let i = 0; i < sizeNames.length; i += 1) {\r\n    const size = sizeNames[i];\r\n    const keyVisible = `${size}Visible`;\r\n    const keyHidden = `${size}Hidden`;\r\n\r\n    // Mutual prop exclusivity is expected and validated using prop types.\r\n    // Therefore we can here assume that in each iteration only one of following\r\n    // will be executed.\r\n    if (Object.prototype.hasOwnProperty.call(props, keyVisible)) {\r\n      value = !props[keyVisible];\r\n    }\r\n\r\n    if (Object.prototype.hasOwnProperty.call(props, keyHidden)) {\r\n      value = props[keyHidden];\r\n    }\r\n\r\n    // If matched current size, early return to stop further iteration.\r\n    if (activeSize === size) {\r\n      return value;\r\n    }\r\n  }\r\n\r\n  return value;\r\n};\r\n\r\n\r\n/**\r\n * Determines size of component depended on sizing class.\r\n *\r\n * @param {Array<string>} sizeNames that grid supports ordered from smallest\r\n * @param {string} activeSize that is determined by grid\r\n * @param {Object} props object use as reference for values\r\n * @return {any}\r\n */\r\nconst getSize = (sizeNames, activeSize, props) => {\r\n  const initialValue = (props.size || '1');\r\n  const keySelector = size => `${size}Size`;\r\n\r\n  return valueForSize(sizeNames, activeSize, props, initialValue, keySelector);\r\n};\r\n\r\n\r\n/**\r\n * Determines width percentage of component depended on currently active size.\r\n *\r\n * Since attributes cascade from smaller to larger dimensions it will determine\r\n * which one to use and return it's value. This enables easy way to determine\r\n * element size.\r\n *\r\n * For example `mdSize=\"1/2\"` will return 50% on medium sized but as well\r\n * on all larger sizes, unless overridden with larger size.\r\n *\r\n * It returns full with if there is none matching current size (either none is\r\n * smaller or there were no provided).\r\n *\r\n * @param {Array<string>} sizeNames that grid supports ordered from smallest\r\n * @param {string} activeSize that is determined by grid\r\n * @param {Object} props object use as reference for values\r\n * @return {number | string} representing width/height as percentage\r\n */\r\nexport const determineSize = (sizeNames, activeSize, props) => {\r\n  const size = getSize(sizeNames, activeSize, props);\r\n\r\n  if (size === 'stretch') {\r\n    return size;\r\n  }\r\n\r\n  if ((typeof size) === 'string') {\r\n    // If string represents percentages\r\n    if (size.endsWith('%')) {\r\n      return size;\r\n    }\r\n\r\n    // If string represents fractions\r\n    return `${FRACTION_VALUES[size]}%`;\r\n  }\r\n\r\n  return size;\r\n};\r\n"]},"metadata":{},"sourceType":"module"}