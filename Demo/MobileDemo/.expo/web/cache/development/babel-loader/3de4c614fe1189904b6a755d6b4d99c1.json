{"ast":null,"code":"var ROUNDING_FACTOR = 10000;\nexport var roundForPercentage = function roundForPercentage(percent) {\n  return Math.floor(percent * ROUNDING_FACTOR) / ROUNDING_FACTOR;\n};\nexport var valueForSize = function valueForSize(sizeNames, activeSize, props, initialValue, keySelector) {\n  var value = initialValue;\n\n  for (var i = 0; i < sizeNames.length; i += 1) {\n    var size = sizeNames[i];\n    var key = keySelector(size);\n\n    if (Object.prototype.hasOwnProperty.call(props, key)) {\n      value = props[key];\n    }\n\n    if (activeSize === size) {\n      return value;\n    }\n  }\n\n  return value;\n};","map":{"version":3,"sources":["C:/Users/mikea/Documents/GitHub/MobileDemo/Demo/MobileDemo/node_modules/react-native-responsive-layout/src/shared/methods.js"],"names":["ROUNDING_FACTOR","roundForPercentage","percent","Math","floor","valueForSize","sizeNames","activeSize","props","initialValue","keySelector","value","i","length","size","key","Object","prototype","hasOwnProperty","call"],"mappings":"AACA,IAAMA,eAAe,GAAG,KAAxB;AASA,OAAO,IAAMC,kBAAkB,GAAG,SAArBA,kBAAqB,CAAAC,OAAO;AAAA,SACvCC,IAAI,CAACC,KAAL,CAAWF,OAAO,GAAGF,eAArB,IAAwCA,eADD;AAAA,CAAlC;AAiBP,OAAO,IAAMK,YAAY,GAAG,SAAfA,YAAe,CAACC,SAAD,EAAYC,UAAZ,EAAwBC,KAAxB,EAA+BC,YAA/B,EAA6CC,WAA7C,EAA6D;AACvF,MAAIC,KAAK,GAAGF,YAAZ;;AAEA,OAAK,IAAIG,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGN,SAAS,CAACO,MAA9B,EAAsCD,CAAC,IAAI,CAA3C,EAA8C;AAC5C,QAAME,IAAI,GAAGR,SAAS,CAACM,CAAD,CAAtB;AACA,QAAMG,GAAG,GAAGL,WAAW,CAACI,IAAD,CAAvB;;AAGA,QAAIE,MAAM,CAACC,SAAP,CAAiBC,cAAjB,CAAgCC,IAAhC,CAAqCX,KAArC,EAA4CO,GAA5C,CAAJ,EAAsD;AACpDJ,MAAAA,KAAK,GAAGH,KAAK,CAACO,GAAD,CAAb;AACD;;AAGD,QAAIR,UAAU,KAAKO,IAAnB,EAAyB;AACvB,aAAOH,KAAP;AACD;AACF;;AAED,SAAOA,KAAP;AACD,CAnBM","sourcesContent":["\nconst ROUNDING_FACTOR = 10000;\n\n/**\n * Rounds down percent to ensure that total width won't exceed 100% fixing\n * issues with floating point representation of specific widths.\n *\n * @param {number} percent\n * @returns {number}\n */\nexport const roundForPercentage = percent => (\n  Math.floor(percent * ROUNDING_FACTOR) / ROUNDING_FACTOR\n);\n\n\n/**\n * Utility method used to pick the largest value that is smaller than current\n * gird width. It is used to pick best fitting object from keys that would fit\n * as well.\n *\n * @param {Array<string>} sizeNames array of grid sizes\n * @param {string} activeSize active grid size\n * @param {Object} props object containing values for sizes\n * @param {any} initialValue default value if none matches\n * @param {function(string): string} keySelector function that generates key to access value\n * @returns {any}\n */\nexport const valueForSize = (sizeNames, activeSize, props, initialValue, keySelector) => {\n  let value = initialValue;\n\n  for (let i = 0; i < sizeNames.length; i += 1) {\n    const size = sizeNames[i];\n    const key = keySelector(size);\n\n    // Ensure that key is updated on each size that is before.\n    if (Object.prototype.hasOwnProperty.call(props, key)) {\n      value = props[key];\n    }\n\n    // If matched current size, early return to stop further iteration.\n    if (activeSize === size) {\n      return value;\n    }\n  }\n\n  return value;\n};\n"]},"metadata":{},"sourceType":"module"}