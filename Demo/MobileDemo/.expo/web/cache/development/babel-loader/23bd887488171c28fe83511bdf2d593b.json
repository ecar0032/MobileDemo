{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nimport PropTypes from 'prop-types';\nimport { FRACTION_NAMES, SIZE_NAMES } from \"../../shared/constants\";\n\nvar isFraction = function isFraction(value) {\n  return FRACTION_NAMES.indexOf(value) !== -1;\n};\n\nvar percentageMatcher = /^\\d+(\\.\\d+)?%$/;\n\nvar isPercentage = function isPercentage(value) {\n  return percentageMatcher.test(value);\n};\n\nexport var SizeProp = function SizeProp(props, propName) {\n  var size = props[propName];\n\n  if (typeof size === 'string') {\n    if (isFraction(size) || isPercentage(size) || size === 'stretch') {\n      return undefined;\n    }\n\n    return new Error(\"'\" + propName + \"' string argument should be valid fraction, percentage or stretch. \\nGot: \\\"\" + size + \"\\\"\");\n  }\n\n  if (typeof size === 'number') {\n    if (size >= 0) {\n      return undefined;\n    }\n\n    return new Error(propName + \" should be positive number. \\nGot: \" + size + \"%.\");\n  }\n\n  if (size !== undefined) {\n    return new Error(propName + \" should be either string fraction or numerical percentage. \\nGot: \" + size);\n  }\n\n  return undefined;\n};\nexport var HiddenProp = function HiddenProp(sizeName) {\n  return function (props, propName) {\n    var visibleKey = sizeName ? sizeName + \"Visible\" : 'visible';\n    var hiddenKey = sizeName ? sizeName + \"Hidden\" : 'hidden';\n\n    if (props[visibleKey] && props[hiddenKey]) {\n      return new Error(\"'\" + propName + \"' has also defined \" + visibleKey + \" prop, this leads to unexpected behavior.\");\n    }\n\n    var size = props[propName];\n\n    if (size !== undefined && typeof size !== 'boolean') {\n      return new Error(\"'\" + propName + \"' should be boolean. \\nGot: \\\"\" + size + \"\\\"\");\n    }\n\n    return undefined;\n  };\n};\n\nvar BreakpointProps = function () {\n  var props = {\n    size: SizeProp\n  };\n  SIZE_NAMES.forEach(function (size) {\n    props[size + \"Size\"] = SizeProp;\n  });\n  return props;\n}();\n\nvar HiddenProps = function () {\n  var props = {\n    hidden: HiddenProp(),\n    visible: PropTypes.bool\n  };\n  SIZE_NAMES.forEach(function (size) {\n    props[size + \"Hidden\"] = HiddenProp(size);\n    props[size + \"Visible\"] = PropTypes.bool;\n  });\n  return props;\n}();\n\nvar BlockProps = _objectSpread(_objectSpread({}, BreakpointProps), HiddenProps);\n\nexport default BlockProps;","map":{"version":3,"sources":["C:/Users/mikea/Documents/GitHub/MobileDemo/Demo/MobileDemo/node_modules/react-native-responsive-layout/src/components/block/props.js"],"names":["PropTypes","FRACTION_NAMES","SIZE_NAMES","isFraction","value","indexOf","percentageMatcher","isPercentage","test","SizeProp","props","propName","size","undefined","Error","HiddenProp","sizeName","visibleKey","hiddenKey","BreakpointProps","forEach","HiddenProps","hidden","visible","bool","BlockProps"],"mappings":"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","sourcesContent":["import PropTypes from 'prop-types';\n\nimport {\n  FRACTION_NAMES,\n  SIZE_NAMES,\n} from '../../shared/constants';\n\n/**\n * Checks whether provided value is valid fraction.\n *\n * @param {string} value to check\n * @return {boolean} true if it is fraction\n */\nconst isFraction = value => (FRACTION_NAMES.indexOf(value) !== -1);\n\n/**\n * Regex used to validate percentages, this way it is reused.\n */\nconst percentageMatcher = /^\\d+(\\.\\d+)?%$/;\n\n/**\n * Checks whether provided string is valid percentage.\n *\n * @param {string} value  to check\n * @return {boolean} true if it is percentage\n */\nconst isPercentage = value => percentageMatcher.test(value);\n\n\n/**\n * PropType that validates grid element size to be either string fraction or\n * numerical percentage.\n *\n * @param {Object} props\n * @param {string} propName\n * @return {Error | undefined}\n */\nexport const SizeProp = (props, propName) => {\n  const size = props[propName];\n\n  if (typeof size === 'string') {\n    if (isFraction(size) || isPercentage(size) || size === 'stretch') {\n      return undefined;\n    }\n    return new Error(`'${propName}' string argument should be valid fraction, percentage or stretch. \\nGot: \"${size}\"`);\n  }\n\n  if (typeof size === 'number') {\n    if (size >= 0) {\n      return undefined;\n    }\n    return new Error(`${propName} should be positive number. \\nGot: ${size}%.`);\n  }\n\n  if (size !== undefined) {\n    return new Error(`${propName} should be either string fraction or numerical percentage. \\nGot: ${size}`);\n  }\n\n  return undefined;\n};\n\n\n/**\n * PropType that validates hidden/visible elements and their exclusivity.\n *\n * @param {string=} sizeName\n * @return {function(Object, string): Error | undefined}\n */\nexport const HiddenProp = sizeName => (props, propName) => {\n  const visibleKey = sizeName ? `${sizeName}Visible` : 'visible';\n  const hiddenKey = sizeName ? `${sizeName}Hidden` : 'hidden';\n\n  if (props[visibleKey] && props[hiddenKey]) {\n    return new Error(`'${propName}' has also defined ${visibleKey} prop, this leads to unexpected behavior.`);\n  }\n\n  const size = props[propName];\n\n  if (size !== undefined && typeof size !== 'boolean') {\n    return new Error(`'${propName}' should be boolean. \\nGot: \"${size}\"`);\n  }\n\n  return undefined;\n};\n\n\n/**\n * Defines prop validation for all sizes to be valid string or number.\n */\nconst BreakpointProps = (() => {\n  const props = { size: SizeProp };\n  SIZE_NAMES.forEach((size) => {\n    props[`${size}Size`] = SizeProp;\n  });\n  return props;\n})();\n\n\n/**\n * Defines hidden attribute prop validations for all sizes.\n */\nconst HiddenProps = (() => {\n  // Defining only hidden will ensure that if both are defined proper message\n  // is displayed, if it was defined on both it would display same error twice.\n  const props = {\n    hidden: HiddenProp(),\n    visible: PropTypes.bool,\n  };\n\n  SIZE_NAMES.forEach((size) => {\n    props[`${size}Hidden`] = HiddenProp(size);\n    props[`${size}Visible`] = PropTypes.bool;\n  });\n\n  return props;\n})();\n\n\n/**\n * Merge of all prop validations that are required for Block element.\n */\nconst BlockProps = {\n  ...BreakpointProps,\n  ...HiddenProps,\n};\n\nexport default BlockProps;\n"]},"metadata":{},"sourceType":"module"}